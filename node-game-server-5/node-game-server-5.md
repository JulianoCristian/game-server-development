#pomelo框架的设计动机与架构介绍

在本系列第一篇文章中我们介绍了游戏服务器的基础、难点、框架,以及用pomelo框架解决了运行架构的问题。 随后两篇文章我们通过示例介绍了用pomelo开发聊天服务器、捡宝游戏的开发过程。
代码示例让我们对pomelo有了很好的感性认识。现在是时候回过头来详细分析一下pomelo的设计细节，架构以及未来的发展方向了。 

## 一、Pomelo的定义和组成


以下是Pomelo官网给出的最初定义：Pomelo是基于node.js的高性能,分布式游戏服务器框架。它包括基础的开发框架和相关的扩展组件（库和工具包），可以帮助你省去游戏开发枯燥中的重复劳动和底层逻辑的开发。

Pomelo最初的设计初衷是为了游戏服务器， 不过我们在设计、开发完成后发现pomelo是个通用的分布式实时应用开发框架。它的灵活性和可扩展性使pomelo框架有了更广阔的应用范围。 由于强大的可能伸缩性和灵活性，pomelo在很多方面甚至超越了现有的开源实时应用框架。

如果你浏览一下[网易的github](https://github.com/NetEase/)，会发现pomelo远远不止是一个repository， 它是由一系列松耦合的组件组合在一起的，包括了各类demo， 各类客户端，各种库和工具。

下图是pomelo最初的组成图：
 ![pomelo框架](http://pomelo.netease.com/resource/documentImage/pomeloFramework.png)

pomelo包括以下几部分:

* 框架, 框架是pomelo最核心的部分。
* 库，pomelo提供了很多库，有些是跟游戏逻辑完全相关的，如[AI](https://github.com/NetEase/pomelo-bt)，[AOI](https://github.com/NetEase/pomelo-aoi)，[寻路](https://github.com/NetEase/pomelo-pathfinding)等；也有与游戏逻辑无关的，如[定时任务执行](https://github.com/NetEase/pomelo-scheduler)， [数据同步](https://github.com/NetEase/pomelo-sync)。
* 工具，pomelo提供了管理控制台、命令行工具、压力测试工具等一系列工具。
* 各类客户端， pomelo提供了各类平台的客户端，包括js, C, android, iOS, unity3d等，这些都可以从pomelo的官方主页查到。
* Demo， 一个框架需要强大的demo来展示功能，pomelo提供了全平台的聊天demo和[基于HTML5的捡宝Demo](https://github.com/NetEase/treasures)，系统还提供了一个强大的基于HTML5开发的强大的MMO游戏demo [Lord Of Pomelo](https://github.com/NetEase/lordofpomelo)。

而最妙的地方在于所有这些组件都是松耦合的，所有这些组件都可以独立使用。这使pomelo框架异常灵活，它可
由于篇幅有限，本篇文章只讨论pomelo框架。

## 二、游戏服务器开发架构分析

### 游戏服务器运行架构的演变

网络游戏运行架构的演化可以通过下图说明：



最初的网络服务器是单进程的架构，所有的逻辑都在单台服务器内完成， 这对于同时在线要求不高的游戏是可以这么做的。由于同时在线人数的上升， 单服务器的可伸缩性必然受到挑战。

随着网络游戏对可伸缩性要求的增加，分布式是必然的趋势的。

游戏服务器的分布式架构与Web服务器是不同的， 以下是web服务器与游戏服务器架构的区别：

* 长连接与短连接。web应用使用基于http的短连接以达到最大的可扩展性，游戏应用采用基于socket(websocket)的长连接，以达到最大的实时性。
* 分区策略不同。web应用的分区可以根据负载均衡自由决定， 而游戏则是基于场景(area)的分区模式， 这使同场景的玩家跑在一个进程内， 以达到最少的跨进程调用。
* 有状态和无状态。web应用是无状态的， 可以达到无限的扩展。 而游戏应用则是有状态的， 由于基于场景的分区策略，它的请求必须路由到指定的服务器， 这也使游戏达不到web应用同样的可扩展性。
* 广播模式和request/response模式。web应用采用了基于request/response的请求响应模式。而游戏应用则更频繁地使用广播， 由于玩家在游戏里的行动要实时地通知场景中的其它玩家， 必须通过广播的模式实时发送。这也使游戏在网络通信上的要求高于web应用。


因此， Web应用与游戏应用的运行架构也完全不同， 下图是通常web应用与游戏应用的不同：




可以看到由于web服务器的无状态性，只需要通过前端的负载均衡器可以导向任意一个进程。
而游戏服务器是蜘蛛网式的架构，每个进程都有各自的职责，这些进程的交织在一起共同完成一件任务。这就是一个标准的分布式开发架构。这个分布式的开发架构有它很多的难点.


### 分布式开发与难点

几乎在很多书、演讲和文章中都可以看到这样的观点： 分布式开发是很难的。 如果把所有这些难点都合起来也许有好几本书，我们今天着重看来一下游戏服务器开发的难点吧。

#### 多进程（服务器）的管理，重量级的架构影响开发效率

通常的游戏服务器要由很多进程共同去完成任务。当这些进程交织在一起的时候，多进程的管理并不那么容易。

* 如果没有统一的抽象与管理，光把这些开发环境的进程启动起来就是非常复杂的工作， 进程的启动与重启就将严重影响开发效率。
* 重量级的进程消耗大量的机器资源，普通的开发机支撑不了那么多进程，可能一个人的开发环境就需要多台机器。
* 多进程间的调试并不容易， 我们发现一个bug就要跨好几个进程。

我们会发现利用pomelo的服务器抽象加上node.js的轻量级进程来处理这件事是多么的轻而易举。


#### rpc调用

rpc调用的解决方案已经有n多年的历史了，但rpc在分布式开发效率上仍然没有明显提升。

以当前最流行的开发框架thrift为例，它在能调用代码前需要经过以下步骤：


如果发生接口改动，我们又需要重新修改描述文件，重新生成stub接口。对于接口不稳定的开发环境， 这种方式对开发效率影响较大。

要想让rpc调用的开发达到最简，不需生成stub接口， 无需描述文件， 我们需要一种很巧妙的方法。


#### 分布式事务、异步化操作

尽管我们尽量把逻辑放在一个进程里处理，但分布式事务仍然是不可避免的。两阶段提交的代码，异步化的操作在普通的开发语言里并不是容易的事。

但我们会发现用了node.js之后，它的编程模式里天生就是这种模式， 两阶段提交、异步化操作这些看似复杂的工作里在node.js只是一个正常的异步执行流程。


####  负载均衡，高可用

由于游戏服务器的有状态性，很多请求需要通过特定的路由规则导到某台服务器；对于有些无状态的服务器，我们则可以把请求路由到负载最低的服务器。

通常对于无状态的服务器， 高可用是比较好做的。
对于有状态的服务器，要做高可用会非常困难， 但也不是完全没有办法，常见的两招：

* 将状态引出到外存，例如redis， 这样进程本身就可以无状态了。但由于所有的操作都通过redis可能带来性能损耗，有些场景是不能应会这些损耗的。
* 通过进程互备， 将状态通过日志等方式同步到另一进程， 但这可能存在着瞬间数据丢失的问题。但确实可以做到进程的快速恢复。


### Node.js的引入

node.js的引入优势明显。 


## 四、pomelo架构分析

令人吃惊的是，在pomelo上进行分布式开发几乎与单机一样方便， 让我们看看pomelo是怎么做到的。


### 灵活、轻量的进程管理

### 轻量的应用请求响应和rpc调用 

### 灵活的路由与负载均衡配置




## 五、从游戏框架到实时应用框架

当我们开发完成pomelo框架的时候，我们发现pomelo与游戏服务器没有任何关系。

### 更好的实时应用框架

pomelo游戏框架


### 支持各类客户端

### 灵活扩展




## 六、未来发展方向

### 分布式开发的模板

### 


